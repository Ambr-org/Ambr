// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#ifndef PROTOBUF_INCLUDED_rpc_2eproto
#define PROTOBUF_INCLUDED_rpc_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_rpc_2eproto 

namespace protobuf_rpc_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_rpc_2eproto
namespace ambr {
namespace rpc {
class AddUnitReply;
class AddUnitReplyDefaultTypeInternal;
extern AddUnitReplyDefaultTypeInternal _AddUnitReply_default_instance_;
class AddUnitRequest;
class AddUnitRequestDefaultTypeInternal;
extern AddUnitRequestDefaultTypeInternal _AddUnitRequest_default_instance_;
class GetBalanceReply;
class GetBalanceReplyDefaultTypeInternal;
extern GetBalanceReplyDefaultTypeInternal _GetBalanceReply_default_instance_;
class GetBalanceRequest;
class GetBalanceRequestDefaultTypeInternal;
extern GetBalanceRequestDefaultTypeInternal _GetBalanceRequest_default_instance_;
class GetHistoryReply;
class GetHistoryReplyDefaultTypeInternal;
extern GetHistoryReplyDefaultTypeInternal _GetHistoryReply_default_instance_;
class GetHistoryRequest;
class GetHistoryRequestDefaultTypeInternal;
extern GetHistoryRequestDefaultTypeInternal _GetHistoryRequest_default_instance_;
class GetLastUnitHashReplay;
class GetLastUnitHashReplayDefaultTypeInternal;
extern GetLastUnitHashReplayDefaultTypeInternal _GetLastUnitHashReplay_default_instance_;
class GetLastUnitHashRequest;
class GetLastUnitHashRequestDefaultTypeInternal;
extern GetLastUnitHashRequestDefaultTypeInternal _GetLastUnitHashRequest_default_instance_;
class GetWaitForReceiveUnitReply;
class GetWaitForReceiveUnitReplyDefaultTypeInternal;
extern GetWaitForReceiveUnitReplyDefaultTypeInternal _GetWaitForReceiveUnitReply_default_instance_;
class GetWaitForReceiveUnitRequest;
class GetWaitForReceiveUnitRequestDefaultTypeInternal;
extern GetWaitForReceiveUnitRequestDefaultTypeInternal _GetWaitForReceiveUnitRequest_default_instance_;
class HistoryItem;
class HistoryItemDefaultTypeInternal;
extern HistoryItemDefaultTypeInternal _HistoryItem_default_instance_;
class MessageStreamReply;
class MessageStreamReplyDefaultTypeInternal;
extern MessageStreamReplyDefaultTypeInternal _MessageStreamReply_default_instance_;
class MessageStreamRequest;
class MessageStreamRequestDefaultTypeInternal;
extern MessageStreamRequestDefaultTypeInternal _MessageStreamRequest_default_instance_;
class SendMessageReply;
class SendMessageReplyDefaultTypeInternal;
extern SendMessageReplyDefaultTypeInternal _SendMessageReply_default_instance_;
class SendMessageRequest;
class SendMessageRequestDefaultTypeInternal;
extern SendMessageRequestDefaultTypeInternal _SendMessageRequest_default_instance_;
class WaitForReceiveItem;
class WaitForReceiveItemDefaultTypeInternal;
extern WaitForReceiveItemDefaultTypeInternal _WaitForReceiveItem_default_instance_;
}  // namespace rpc
}  // namespace ambr
namespace google {
namespace protobuf {
template<> ::ambr::rpc::AddUnitReply* Arena::CreateMaybeMessage<::ambr::rpc::AddUnitReply>(Arena*);
template<> ::ambr::rpc::AddUnitRequest* Arena::CreateMaybeMessage<::ambr::rpc::AddUnitRequest>(Arena*);
template<> ::ambr::rpc::GetBalanceReply* Arena::CreateMaybeMessage<::ambr::rpc::GetBalanceReply>(Arena*);
template<> ::ambr::rpc::GetBalanceRequest* Arena::CreateMaybeMessage<::ambr::rpc::GetBalanceRequest>(Arena*);
template<> ::ambr::rpc::GetHistoryReply* Arena::CreateMaybeMessage<::ambr::rpc::GetHistoryReply>(Arena*);
template<> ::ambr::rpc::GetHistoryRequest* Arena::CreateMaybeMessage<::ambr::rpc::GetHistoryRequest>(Arena*);
template<> ::ambr::rpc::GetLastUnitHashReplay* Arena::CreateMaybeMessage<::ambr::rpc::GetLastUnitHashReplay>(Arena*);
template<> ::ambr::rpc::GetLastUnitHashRequest* Arena::CreateMaybeMessage<::ambr::rpc::GetLastUnitHashRequest>(Arena*);
template<> ::ambr::rpc::GetWaitForReceiveUnitReply* Arena::CreateMaybeMessage<::ambr::rpc::GetWaitForReceiveUnitReply>(Arena*);
template<> ::ambr::rpc::GetWaitForReceiveUnitRequest* Arena::CreateMaybeMessage<::ambr::rpc::GetWaitForReceiveUnitRequest>(Arena*);
template<> ::ambr::rpc::HistoryItem* Arena::CreateMaybeMessage<::ambr::rpc::HistoryItem>(Arena*);
template<> ::ambr::rpc::MessageStreamReply* Arena::CreateMaybeMessage<::ambr::rpc::MessageStreamReply>(Arena*);
template<> ::ambr::rpc::MessageStreamRequest* Arena::CreateMaybeMessage<::ambr::rpc::MessageStreamRequest>(Arena*);
template<> ::ambr::rpc::SendMessageReply* Arena::CreateMaybeMessage<::ambr::rpc::SendMessageReply>(Arena*);
template<> ::ambr::rpc::SendMessageRequest* Arena::CreateMaybeMessage<::ambr::rpc::SendMessageRequest>(Arena*);
template<> ::ambr::rpc::WaitForReceiveItem* Arena::CreateMaybeMessage<::ambr::rpc::WaitForReceiveItem>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ambr {
namespace rpc {

// ===================================================================

class AddUnitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.AddUnitRequest) */ {
 public:
  AddUnitRequest();
  virtual ~AddUnitRequest();

  AddUnitRequest(const AddUnitRequest& from);

  inline AddUnitRequest& operator=(const AddUnitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddUnitRequest(AddUnitRequest&& from) noexcept
    : AddUnitRequest() {
    *this = ::std::move(from);
  }

  inline AddUnitRequest& operator=(AddUnitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddUnitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddUnitRequest* internal_default_instance() {
    return reinterpret_cast<const AddUnitRequest*>(
               &_AddUnitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AddUnitRequest* other);
  friend void swap(AddUnitRequest& a, AddUnitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddUnitRequest* New() const final {
    return CreateMaybeMessage<AddUnitRequest>(NULL);
  }

  AddUnitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddUnitRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddUnitRequest& from);
  void MergeFrom(const AddUnitRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddUnitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string json = 1;
  void clear_json();
  static const int kJsonFieldNumber = 1;
  const ::std::string& json() const;
  void set_json(const ::std::string& value);
  #if LANG_CXX11
  void set_json(::std::string&& value);
  #endif
  void set_json(const char* value);
  void set_json(const char* value, size_t size);
  ::std::string* mutable_json();
  ::std::string* release_json();
  void set_allocated_json(::std::string* json);

  // @@protoc_insertion_point(class_scope:ambr.rpc.AddUnitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr json_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddUnitReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.AddUnitReply) */ {
 public:
  AddUnitReply();
  virtual ~AddUnitReply();

  AddUnitReply(const AddUnitReply& from);

  inline AddUnitReply& operator=(const AddUnitReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddUnitReply(AddUnitReply&& from) noexcept
    : AddUnitReply() {
    *this = ::std::move(from);
  }

  inline AddUnitReply& operator=(AddUnitReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddUnitReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddUnitReply* internal_default_instance() {
    return reinterpret_cast<const AddUnitReply*>(
               &_AddUnitReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AddUnitReply* other);
  friend void swap(AddUnitReply& a, AddUnitReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddUnitReply* New() const final {
    return CreateMaybeMessage<AddUnitReply>(NULL);
  }

  AddUnitReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddUnitReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddUnitReply& from);
  void MergeFrom(const AddUnitReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddUnitReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_message = 2;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:ambr.rpc.AddUnitReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  bool result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitForReceiveItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.WaitForReceiveItem) */ {
 public:
  WaitForReceiveItem();
  virtual ~WaitForReceiveItem();

  WaitForReceiveItem(const WaitForReceiveItem& from);

  inline WaitForReceiveItem& operator=(const WaitForReceiveItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitForReceiveItem(WaitForReceiveItem&& from) noexcept
    : WaitForReceiveItem() {
    *this = ::std::move(from);
  }

  inline WaitForReceiveItem& operator=(WaitForReceiveItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitForReceiveItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitForReceiveItem* internal_default_instance() {
    return reinterpret_cast<const WaitForReceiveItem*>(
               &_WaitForReceiveItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(WaitForReceiveItem* other);
  friend void swap(WaitForReceiveItem& a, WaitForReceiveItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitForReceiveItem* New() const final {
    return CreateMaybeMessage<WaitForReceiveItem>(NULL);
  }

  WaitForReceiveItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitForReceiveItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitForReceiveItem& from);
  void MergeFrom(const WaitForReceiveItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitForReceiveItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // @@protoc_insertion_point(class_scope:ambr.rpc.WaitForReceiveItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWaitForReceiveUnitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.GetWaitForReceiveUnitRequest) */ {
 public:
  GetWaitForReceiveUnitRequest();
  virtual ~GetWaitForReceiveUnitRequest();

  GetWaitForReceiveUnitRequest(const GetWaitForReceiveUnitRequest& from);

  inline GetWaitForReceiveUnitRequest& operator=(const GetWaitForReceiveUnitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetWaitForReceiveUnitRequest(GetWaitForReceiveUnitRequest&& from) noexcept
    : GetWaitForReceiveUnitRequest() {
    *this = ::std::move(from);
  }

  inline GetWaitForReceiveUnitRequest& operator=(GetWaitForReceiveUnitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWaitForReceiveUnitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWaitForReceiveUnitRequest* internal_default_instance() {
    return reinterpret_cast<const GetWaitForReceiveUnitRequest*>(
               &_GetWaitForReceiveUnitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetWaitForReceiveUnitRequest* other);
  friend void swap(GetWaitForReceiveUnitRequest& a, GetWaitForReceiveUnitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetWaitForReceiveUnitRequest* New() const final {
    return CreateMaybeMessage<GetWaitForReceiveUnitRequest>(NULL);
  }

  GetWaitForReceiveUnitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetWaitForReceiveUnitRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetWaitForReceiveUnitRequest& from);
  void MergeFrom(const GetWaitForReceiveUnitRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWaitForReceiveUnitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:ambr.rpc.GetWaitForReceiveUnitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWaitForReceiveUnitReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.GetWaitForReceiveUnitReply) */ {
 public:
  GetWaitForReceiveUnitReply();
  virtual ~GetWaitForReceiveUnitReply();

  GetWaitForReceiveUnitReply(const GetWaitForReceiveUnitReply& from);

  inline GetWaitForReceiveUnitReply& operator=(const GetWaitForReceiveUnitReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetWaitForReceiveUnitReply(GetWaitForReceiveUnitReply&& from) noexcept
    : GetWaitForReceiveUnitReply() {
    *this = ::std::move(from);
  }

  inline GetWaitForReceiveUnitReply& operator=(GetWaitForReceiveUnitReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWaitForReceiveUnitReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWaitForReceiveUnitReply* internal_default_instance() {
    return reinterpret_cast<const GetWaitForReceiveUnitReply*>(
               &_GetWaitForReceiveUnitReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetWaitForReceiveUnitReply* other);
  friend void swap(GetWaitForReceiveUnitReply& a, GetWaitForReceiveUnitReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetWaitForReceiveUnitReply* New() const final {
    return CreateMaybeMessage<GetWaitForReceiveUnitReply>(NULL);
  }

  GetWaitForReceiveUnitReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetWaitForReceiveUnitReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetWaitForReceiveUnitReply& from);
  void MergeFrom(const GetWaitForReceiveUnitReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWaitForReceiveUnitReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ambr.rpc.WaitForReceiveItem items = 2;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 2;
  ::ambr::rpc::WaitForReceiveItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::ambr::rpc::WaitForReceiveItem >*
      mutable_items();
  const ::ambr::rpc::WaitForReceiveItem& items(int index) const;
  ::ambr::rpc::WaitForReceiveItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::ambr::rpc::WaitForReceiveItem >&
      items() const;

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:ambr.rpc.GetWaitForReceiveUnitReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ambr::rpc::WaitForReceiveItem > items_;
  bool result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBalanceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.GetBalanceRequest) */ {
 public:
  GetBalanceRequest();
  virtual ~GetBalanceRequest();

  GetBalanceRequest(const GetBalanceRequest& from);

  inline GetBalanceRequest& operator=(const GetBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBalanceRequest(GetBalanceRequest&& from) noexcept
    : GetBalanceRequest() {
    *this = ::std::move(from);
  }

  inline GetBalanceRequest& operator=(GetBalanceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBalanceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBalanceRequest* internal_default_instance() {
    return reinterpret_cast<const GetBalanceRequest*>(
               &_GetBalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetBalanceRequest* other);
  friend void swap(GetBalanceRequest& a, GetBalanceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBalanceRequest* New() const final {
    return CreateMaybeMessage<GetBalanceRequest>(NULL);
  }

  GetBalanceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBalanceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBalanceRequest& from);
  void MergeFrom(const GetBalanceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:ambr.rpc.GetBalanceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetBalanceReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.GetBalanceReply) */ {
 public:
  GetBalanceReply();
  virtual ~GetBalanceReply();

  GetBalanceReply(const GetBalanceReply& from);

  inline GetBalanceReply& operator=(const GetBalanceReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBalanceReply(GetBalanceReply&& from) noexcept
    : GetBalanceReply() {
    *this = ::std::move(from);
  }

  inline GetBalanceReply& operator=(GetBalanceReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBalanceReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBalanceReply* internal_default_instance() {
    return reinterpret_cast<const GetBalanceReply*>(
               &_GetBalanceReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetBalanceReply* other);
  friend void swap(GetBalanceReply& a, GetBalanceReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBalanceReply* New() const final {
    return CreateMaybeMessage<GetBalanceReply>(NULL);
  }

  GetBalanceReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBalanceReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBalanceReply& from);
  void MergeFrom(const GetBalanceReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // string error_message = 3;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:ambr.rpc.GetBalanceReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  bool result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HistoryItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.HistoryItem) */ {
 public:
  HistoryItem();
  virtual ~HistoryItem();

  HistoryItem(const HistoryItem& from);

  inline HistoryItem& operator=(const HistoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HistoryItem(HistoryItem&& from) noexcept
    : HistoryItem() {
    *this = ::std::move(from);
  }

  inline HistoryItem& operator=(HistoryItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoryItem* internal_default_instance() {
    return reinterpret_cast<const HistoryItem*>(
               &_HistoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(HistoryItem* other);
  friend void swap(HistoryItem& a, HistoryItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HistoryItem* New() const final {
    return CreateMaybeMessage<HistoryItem>(NULL);
  }

  HistoryItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HistoryItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HistoryItem& from);
  void MergeFrom(const HistoryItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoryItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const char* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // @@protoc_insertion_point(class_scope:ambr.rpc.HistoryItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetHistoryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.GetHistoryRequest) */ {
 public:
  GetHistoryRequest();
  virtual ~GetHistoryRequest();

  GetHistoryRequest(const GetHistoryRequest& from);

  inline GetHistoryRequest& operator=(const GetHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetHistoryRequest(GetHistoryRequest&& from) noexcept
    : GetHistoryRequest() {
    *this = ::std::move(from);
  }

  inline GetHistoryRequest& operator=(GetHistoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetHistoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const GetHistoryRequest*>(
               &_GetHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetHistoryRequest* other);
  friend void swap(GetHistoryRequest& a, GetHistoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetHistoryRequest* New() const final {
    return CreateMaybeMessage<GetHistoryRequest>(NULL);
  }

  GetHistoryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetHistoryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetHistoryRequest& from);
  void MergeFrom(const GetHistoryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHistoryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:ambr.rpc.GetHistoryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetHistoryReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.GetHistoryReply) */ {
 public:
  GetHistoryReply();
  virtual ~GetHistoryReply();

  GetHistoryReply(const GetHistoryReply& from);

  inline GetHistoryReply& operator=(const GetHistoryReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetHistoryReply(GetHistoryReply&& from) noexcept
    : GetHistoryReply() {
    *this = ::std::move(from);
  }

  inline GetHistoryReply& operator=(GetHistoryReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetHistoryReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetHistoryReply* internal_default_instance() {
    return reinterpret_cast<const GetHistoryReply*>(
               &_GetHistoryReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetHistoryReply* other);
  friend void swap(GetHistoryReply& a, GetHistoryReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetHistoryReply* New() const final {
    return CreateMaybeMessage<GetHistoryReply>(NULL);
  }

  GetHistoryReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetHistoryReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetHistoryReply& from);
  void MergeFrom(const GetHistoryReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHistoryReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ambr.rpc.HistoryItem items = 2;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 2;
  ::ambr::rpc::HistoryItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::ambr::rpc::HistoryItem >*
      mutable_items();
  const ::ambr::rpc::HistoryItem& items(int index) const;
  ::ambr::rpc::HistoryItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::ambr::rpc::HistoryItem >&
      items() const;

  // string error_message = 3;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:ambr.rpc.GetHistoryReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ambr::rpc::HistoryItem > items_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  bool result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendMessageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.SendMessageRequest) */ {
 public:
  SendMessageRequest();
  virtual ~SendMessageRequest();

  SendMessageRequest(const SendMessageRequest& from);

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendMessageRequest(SendMessageRequest&& from) noexcept
    : SendMessageRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageRequest& operator=(SendMessageRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendMessageRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageRequest*>(
               &_SendMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SendMessageRequest* other);
  friend void swap(SendMessageRequest& a, SendMessageRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendMessageRequest* New() const final {
    return CreateMaybeMessage<SendMessageRequest>(NULL);
  }

  SendMessageRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendMessageRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SendMessageRequest& from);
  void MergeFrom(const SendMessageRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string json = 1;
  void clear_json();
  static const int kJsonFieldNumber = 1;
  const ::std::string& json() const;
  void set_json(const ::std::string& value);
  #if LANG_CXX11
  void set_json(::std::string&& value);
  #endif
  void set_json(const char* value);
  void set_json(const char* value, size_t size);
  ::std::string* mutable_json();
  ::std::string* release_json();
  void set_allocated_json(::std::string* json);

  // @@protoc_insertion_point(class_scope:ambr.rpc.SendMessageRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr json_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendMessageReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.SendMessageReply) */ {
 public:
  SendMessageReply();
  virtual ~SendMessageReply();

  SendMessageReply(const SendMessageReply& from);

  inline SendMessageReply& operator=(const SendMessageReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendMessageReply(SendMessageReply&& from) noexcept
    : SendMessageReply() {
    *this = ::std::move(from);
  }

  inline SendMessageReply& operator=(SendMessageReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendMessageReply* internal_default_instance() {
    return reinterpret_cast<const SendMessageReply*>(
               &_SendMessageReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SendMessageReply* other);
  friend void swap(SendMessageReply& a, SendMessageReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendMessageReply* New() const final {
    return CreateMaybeMessage<SendMessageReply>(NULL);
  }

  SendMessageReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendMessageReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SendMessageReply& from);
  void MergeFrom(const SendMessageReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_message = 2;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:ambr.rpc.SendMessageReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  bool result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLastUnitHashRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.GetLastUnitHashRequest) */ {
 public:
  GetLastUnitHashRequest();
  virtual ~GetLastUnitHashRequest();

  GetLastUnitHashRequest(const GetLastUnitHashRequest& from);

  inline GetLastUnitHashRequest& operator=(const GetLastUnitHashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLastUnitHashRequest(GetLastUnitHashRequest&& from) noexcept
    : GetLastUnitHashRequest() {
    *this = ::std::move(from);
  }

  inline GetLastUnitHashRequest& operator=(GetLastUnitHashRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLastUnitHashRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLastUnitHashRequest* internal_default_instance() {
    return reinterpret_cast<const GetLastUnitHashRequest*>(
               &_GetLastUnitHashRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetLastUnitHashRequest* other);
  friend void swap(GetLastUnitHashRequest& a, GetLastUnitHashRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLastUnitHashRequest* New() const final {
    return CreateMaybeMessage<GetLastUnitHashRequest>(NULL);
  }

  GetLastUnitHashRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetLastUnitHashRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetLastUnitHashRequest& from);
  void MergeFrom(const GetLastUnitHashRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastUnitHashRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:ambr.rpc.GetLastUnitHashRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLastUnitHashReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.GetLastUnitHashReplay) */ {
 public:
  GetLastUnitHashReplay();
  virtual ~GetLastUnitHashReplay();

  GetLastUnitHashReplay(const GetLastUnitHashReplay& from);

  inline GetLastUnitHashReplay& operator=(const GetLastUnitHashReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLastUnitHashReplay(GetLastUnitHashReplay&& from) noexcept
    : GetLastUnitHashReplay() {
    *this = ::std::move(from);
  }

  inline GetLastUnitHashReplay& operator=(GetLastUnitHashReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLastUnitHashReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLastUnitHashReplay* internal_default_instance() {
    return reinterpret_cast<const GetLastUnitHashReplay*>(
               &_GetLastUnitHashReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GetLastUnitHashReplay* other);
  friend void swap(GetLastUnitHashReplay& a, GetLastUnitHashReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLastUnitHashReplay* New() const final {
    return CreateMaybeMessage<GetLastUnitHashReplay>(NULL);
  }

  GetLastUnitHashReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetLastUnitHashReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetLastUnitHashReplay& from);
  void MergeFrom(const GetLastUnitHashReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLastUnitHashReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string error_message = 3;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:ambr.rpc.GetLastUnitHashReplay)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  bool result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageStreamRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.MessageStreamRequest) */ {
 public:
  MessageStreamRequest();
  virtual ~MessageStreamRequest();

  MessageStreamRequest(const MessageStreamRequest& from);

  inline MessageStreamRequest& operator=(const MessageStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageStreamRequest(MessageStreamRequest&& from) noexcept
    : MessageStreamRequest() {
    *this = ::std::move(from);
  }

  inline MessageStreamRequest& operator=(MessageStreamRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageStreamRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageStreamRequest* internal_default_instance() {
    return reinterpret_cast<const MessageStreamRequest*>(
               &_MessageStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MessageStreamRequest* other);
  friend void swap(MessageStreamRequest& a, MessageStreamRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageStreamRequest* New() const final {
    return CreateMaybeMessage<MessageStreamRequest>(NULL);
  }

  MessageStreamRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageStreamRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageStreamRequest& from);
  void MergeFrom(const MessageStreamRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageStreamRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ambr.rpc.MessageStreamRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageStreamReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ambr.rpc.MessageStreamReply) */ {
 public:
  MessageStreamReply();
  virtual ~MessageStreamReply();

  MessageStreamReply(const MessageStreamReply& from);

  inline MessageStreamReply& operator=(const MessageStreamReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageStreamReply(MessageStreamReply&& from) noexcept
    : MessageStreamReply() {
    *this = ::std::move(from);
  }

  inline MessageStreamReply& operator=(MessageStreamReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageStreamReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageStreamReply* internal_default_instance() {
    return reinterpret_cast<const MessageStreamReply*>(
               &_MessageStreamReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(MessageStreamReply* other);
  friend void swap(MessageStreamReply& a, MessageStreamReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageStreamReply* New() const final {
    return CreateMaybeMessage<MessageStreamReply>(NULL);
  }

  MessageStreamReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageStreamReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageStreamReply& from);
  void MergeFrom(const MessageStreamReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageStreamReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:ambr.rpc.MessageStreamReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rpc_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AddUnitRequest

// string json = 1;
inline void AddUnitRequest::clear_json() {
  json_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddUnitRequest::json() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.AddUnitRequest.json)
  return json_.GetNoArena();
}
inline void AddUnitRequest::set_json(const ::std::string& value) {
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.AddUnitRequest.json)
}
#if LANG_CXX11
inline void AddUnitRequest::set_json(::std::string&& value) {
  
  json_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.AddUnitRequest.json)
}
#endif
inline void AddUnitRequest::set_json(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.AddUnitRequest.json)
}
inline void AddUnitRequest::set_json(const char* value, size_t size) {
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.AddUnitRequest.json)
}
inline ::std::string* AddUnitRequest::mutable_json() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.AddUnitRequest.json)
  return json_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddUnitRequest::release_json() {
  // @@protoc_insertion_point(field_release:ambr.rpc.AddUnitRequest.json)
  
  return json_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddUnitRequest::set_allocated_json(::std::string* json) {
  if (json != NULL) {
    
  } else {
    
  }
  json_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), json);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.AddUnitRequest.json)
}

// -------------------------------------------------------------------

// AddUnitReply

// bool result = 1;
inline void AddUnitReply::clear_result() {
  result_ = false;
}
inline bool AddUnitReply::result() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.AddUnitReply.result)
  return result_;
}
inline void AddUnitReply::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:ambr.rpc.AddUnitReply.result)
}

// string error_message = 2;
inline void AddUnitReply::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddUnitReply::error_message() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.AddUnitReply.error_message)
  return error_message_.GetNoArena();
}
inline void AddUnitReply::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.AddUnitReply.error_message)
}
#if LANG_CXX11
inline void AddUnitReply::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.AddUnitReply.error_message)
}
#endif
inline void AddUnitReply::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.AddUnitReply.error_message)
}
inline void AddUnitReply::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.AddUnitReply.error_message)
}
inline ::std::string* AddUnitReply::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.AddUnitReply.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddUnitReply::release_error_message() {
  // @@protoc_insertion_point(field_release:ambr.rpc.AddUnitReply.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddUnitReply::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.AddUnitReply.error_message)
}

// -------------------------------------------------------------------

// WaitForReceiveItem

// string hash = 1;
inline void WaitForReceiveItem::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WaitForReceiveItem::hash() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.WaitForReceiveItem.hash)
  return hash_.GetNoArena();
}
inline void WaitForReceiveItem::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.WaitForReceiveItem.hash)
}
#if LANG_CXX11
inline void WaitForReceiveItem::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.WaitForReceiveItem.hash)
}
#endif
inline void WaitForReceiveItem::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.WaitForReceiveItem.hash)
}
inline void WaitForReceiveItem::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.WaitForReceiveItem.hash)
}
inline ::std::string* WaitForReceiveItem::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.WaitForReceiveItem.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WaitForReceiveItem::release_hash() {
  // @@protoc_insertion_point(field_release:ambr.rpc.WaitForReceiveItem.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WaitForReceiveItem::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.WaitForReceiveItem.hash)
}

// string amount = 2;
inline void WaitForReceiveItem::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WaitForReceiveItem::amount() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.WaitForReceiveItem.amount)
  return amount_.GetNoArena();
}
inline void WaitForReceiveItem::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.WaitForReceiveItem.amount)
}
#if LANG_CXX11
inline void WaitForReceiveItem::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.WaitForReceiveItem.amount)
}
#endif
inline void WaitForReceiveItem::set_amount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.WaitForReceiveItem.amount)
}
inline void WaitForReceiveItem::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.WaitForReceiveItem.amount)
}
inline ::std::string* WaitForReceiveItem::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.WaitForReceiveItem.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WaitForReceiveItem::release_amount() {
  // @@protoc_insertion_point(field_release:ambr.rpc.WaitForReceiveItem.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WaitForReceiveItem::set_allocated_amount(::std::string* amount) {
  if (amount != NULL) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.WaitForReceiveItem.amount)
}

// -------------------------------------------------------------------

// GetWaitForReceiveUnitRequest

// string public_key = 1;
inline void GetWaitForReceiveUnitRequest::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetWaitForReceiveUnitRequest::public_key() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetWaitForReceiveUnitRequest.public_key)
  return public_key_.GetNoArena();
}
inline void GetWaitForReceiveUnitRequest::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetWaitForReceiveUnitRequest.public_key)
}
#if LANG_CXX11
inline void GetWaitForReceiveUnitRequest::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetWaitForReceiveUnitRequest.public_key)
}
#endif
inline void GetWaitForReceiveUnitRequest::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetWaitForReceiveUnitRequest.public_key)
}
inline void GetWaitForReceiveUnitRequest::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetWaitForReceiveUnitRequest.public_key)
}
inline ::std::string* GetWaitForReceiveUnitRequest::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetWaitForReceiveUnitRequest.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetWaitForReceiveUnitRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetWaitForReceiveUnitRequest.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetWaitForReceiveUnitRequest::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetWaitForReceiveUnitRequest.public_key)
}

// -------------------------------------------------------------------

// GetWaitForReceiveUnitReply

// bool result = 1;
inline void GetWaitForReceiveUnitReply::clear_result() {
  result_ = false;
}
inline bool GetWaitForReceiveUnitReply::result() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetWaitForReceiveUnitReply.result)
  return result_;
}
inline void GetWaitForReceiveUnitReply::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:ambr.rpc.GetWaitForReceiveUnitReply.result)
}

// repeated .ambr.rpc.WaitForReceiveItem items = 2;
inline int GetWaitForReceiveUnitReply::items_size() const {
  return items_.size();
}
inline void GetWaitForReceiveUnitReply::clear_items() {
  items_.Clear();
}
inline ::ambr::rpc::WaitForReceiveItem* GetWaitForReceiveUnitReply::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetWaitForReceiveUnitReply.items)
  return items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ambr::rpc::WaitForReceiveItem >*
GetWaitForReceiveUnitReply::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ambr.rpc.GetWaitForReceiveUnitReply.items)
  return &items_;
}
inline const ::ambr::rpc::WaitForReceiveItem& GetWaitForReceiveUnitReply::items(int index) const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetWaitForReceiveUnitReply.items)
  return items_.Get(index);
}
inline ::ambr::rpc::WaitForReceiveItem* GetWaitForReceiveUnitReply::add_items() {
  // @@protoc_insertion_point(field_add:ambr.rpc.GetWaitForReceiveUnitReply.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ambr::rpc::WaitForReceiveItem >&
GetWaitForReceiveUnitReply::items() const {
  // @@protoc_insertion_point(field_list:ambr.rpc.GetWaitForReceiveUnitReply.items)
  return items_;
}

// -------------------------------------------------------------------

// GetBalanceRequest

// string public_key = 1;
inline void GetBalanceRequest::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBalanceRequest::public_key() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetBalanceRequest.public_key)
  return public_key_.GetNoArena();
}
inline void GetBalanceRequest::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetBalanceRequest.public_key)
}
#if LANG_CXX11
inline void GetBalanceRequest::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetBalanceRequest.public_key)
}
#endif
inline void GetBalanceRequest::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetBalanceRequest.public_key)
}
inline void GetBalanceRequest::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetBalanceRequest.public_key)
}
inline ::std::string* GetBalanceRequest::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetBalanceRequest.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBalanceRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetBalanceRequest.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBalanceRequest::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetBalanceRequest.public_key)
}

// -------------------------------------------------------------------

// GetBalanceReply

// bool result = 1;
inline void GetBalanceReply::clear_result() {
  result_ = false;
}
inline bool GetBalanceReply::result() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetBalanceReply.result)
  return result_;
}
inline void GetBalanceReply::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:ambr.rpc.GetBalanceReply.result)
}

// string amount = 2;
inline void GetBalanceReply::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBalanceReply::amount() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetBalanceReply.amount)
  return amount_.GetNoArena();
}
inline void GetBalanceReply::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetBalanceReply.amount)
}
#if LANG_CXX11
inline void GetBalanceReply::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetBalanceReply.amount)
}
#endif
inline void GetBalanceReply::set_amount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetBalanceReply.amount)
}
inline void GetBalanceReply::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetBalanceReply.amount)
}
inline ::std::string* GetBalanceReply::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetBalanceReply.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBalanceReply::release_amount() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetBalanceReply.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBalanceReply::set_allocated_amount(::std::string* amount) {
  if (amount != NULL) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetBalanceReply.amount)
}

// string error_message = 3;
inline void GetBalanceReply::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBalanceReply::error_message() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetBalanceReply.error_message)
  return error_message_.GetNoArena();
}
inline void GetBalanceReply::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetBalanceReply.error_message)
}
#if LANG_CXX11
inline void GetBalanceReply::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetBalanceReply.error_message)
}
#endif
inline void GetBalanceReply::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetBalanceReply.error_message)
}
inline void GetBalanceReply::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetBalanceReply.error_message)
}
inline ::std::string* GetBalanceReply::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetBalanceReply.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBalanceReply::release_error_message() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetBalanceReply.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBalanceReply::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetBalanceReply.error_message)
}

// -------------------------------------------------------------------

// HistoryItem

// string type = 1;
inline void HistoryItem::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HistoryItem::type() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.HistoryItem.type)
  return type_.GetNoArena();
}
inline void HistoryItem::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.HistoryItem.type)
}
#if LANG_CXX11
inline void HistoryItem::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.HistoryItem.type)
}
#endif
inline void HistoryItem::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.HistoryItem.type)
}
inline void HistoryItem::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.HistoryItem.type)
}
inline ::std::string* HistoryItem::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.HistoryItem.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoryItem::release_type() {
  // @@protoc_insertion_point(field_release:ambr.rpc.HistoryItem.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoryItem::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.HistoryItem.type)
}

// string amount = 2;
inline void HistoryItem::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HistoryItem::amount() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.HistoryItem.amount)
  return amount_.GetNoArena();
}
inline void HistoryItem::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.HistoryItem.amount)
}
#if LANG_CXX11
inline void HistoryItem::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.HistoryItem.amount)
}
#endif
inline void HistoryItem::set_amount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.HistoryItem.amount)
}
inline void HistoryItem::set_amount(const char* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.HistoryItem.amount)
}
inline ::std::string* HistoryItem::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.HistoryItem.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HistoryItem::release_amount() {
  // @@protoc_insertion_point(field_release:ambr.rpc.HistoryItem.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HistoryItem::set_allocated_amount(::std::string* amount) {
  if (amount != NULL) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.HistoryItem.amount)
}

// -------------------------------------------------------------------

// GetHistoryRequest

// string public_key = 1;
inline void GetHistoryRequest::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetHistoryRequest::public_key() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetHistoryRequest.public_key)
  return public_key_.GetNoArena();
}
inline void GetHistoryRequest::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetHistoryRequest.public_key)
}
#if LANG_CXX11
inline void GetHistoryRequest::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetHistoryRequest.public_key)
}
#endif
inline void GetHistoryRequest::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetHistoryRequest.public_key)
}
inline void GetHistoryRequest::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetHistoryRequest.public_key)
}
inline ::std::string* GetHistoryRequest::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetHistoryRequest.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetHistoryRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetHistoryRequest.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetHistoryRequest::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetHistoryRequest.public_key)
}

// -------------------------------------------------------------------

// GetHistoryReply

// bool result = 1;
inline void GetHistoryReply::clear_result() {
  result_ = false;
}
inline bool GetHistoryReply::result() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetHistoryReply.result)
  return result_;
}
inline void GetHistoryReply::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:ambr.rpc.GetHistoryReply.result)
}

// repeated .ambr.rpc.HistoryItem items = 2;
inline int GetHistoryReply::items_size() const {
  return items_.size();
}
inline void GetHistoryReply::clear_items() {
  items_.Clear();
}
inline ::ambr::rpc::HistoryItem* GetHistoryReply::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetHistoryReply.items)
  return items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ambr::rpc::HistoryItem >*
GetHistoryReply::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ambr.rpc.GetHistoryReply.items)
  return &items_;
}
inline const ::ambr::rpc::HistoryItem& GetHistoryReply::items(int index) const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetHistoryReply.items)
  return items_.Get(index);
}
inline ::ambr::rpc::HistoryItem* GetHistoryReply::add_items() {
  // @@protoc_insertion_point(field_add:ambr.rpc.GetHistoryReply.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ambr::rpc::HistoryItem >&
GetHistoryReply::items() const {
  // @@protoc_insertion_point(field_list:ambr.rpc.GetHistoryReply.items)
  return items_;
}

// string error_message = 3;
inline void GetHistoryReply::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetHistoryReply::error_message() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetHistoryReply.error_message)
  return error_message_.GetNoArena();
}
inline void GetHistoryReply::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetHistoryReply.error_message)
}
#if LANG_CXX11
inline void GetHistoryReply::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetHistoryReply.error_message)
}
#endif
inline void GetHistoryReply::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetHistoryReply.error_message)
}
inline void GetHistoryReply::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetHistoryReply.error_message)
}
inline ::std::string* GetHistoryReply::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetHistoryReply.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetHistoryReply::release_error_message() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetHistoryReply.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetHistoryReply::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetHistoryReply.error_message)
}

// -------------------------------------------------------------------

// SendMessageRequest

// string json = 1;
inline void SendMessageRequest::clear_json() {
  json_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageRequest::json() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.SendMessageRequest.json)
  return json_.GetNoArena();
}
inline void SendMessageRequest::set_json(const ::std::string& value) {
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.SendMessageRequest.json)
}
#if LANG_CXX11
inline void SendMessageRequest::set_json(::std::string&& value) {
  
  json_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.SendMessageRequest.json)
}
#endif
inline void SendMessageRequest::set_json(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.SendMessageRequest.json)
}
inline void SendMessageRequest::set_json(const char* value, size_t size) {
  
  json_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.SendMessageRequest.json)
}
inline ::std::string* SendMessageRequest::mutable_json() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.SendMessageRequest.json)
  return json_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageRequest::release_json() {
  // @@protoc_insertion_point(field_release:ambr.rpc.SendMessageRequest.json)
  
  return json_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_allocated_json(::std::string* json) {
  if (json != NULL) {
    
  } else {
    
  }
  json_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), json);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.SendMessageRequest.json)
}

// -------------------------------------------------------------------

// SendMessageReply

// bool result = 1;
inline void SendMessageReply::clear_result() {
  result_ = false;
}
inline bool SendMessageReply::result() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.SendMessageReply.result)
  return result_;
}
inline void SendMessageReply::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:ambr.rpc.SendMessageReply.result)
}

// string error_message = 2;
inline void SendMessageReply::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageReply::error_message() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.SendMessageReply.error_message)
  return error_message_.GetNoArena();
}
inline void SendMessageReply::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.SendMessageReply.error_message)
}
#if LANG_CXX11
inline void SendMessageReply::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.SendMessageReply.error_message)
}
#endif
inline void SendMessageReply::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.SendMessageReply.error_message)
}
inline void SendMessageReply::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.SendMessageReply.error_message)
}
inline ::std::string* SendMessageReply::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.SendMessageReply.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageReply::release_error_message() {
  // @@protoc_insertion_point(field_release:ambr.rpc.SendMessageReply.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageReply::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.SendMessageReply.error_message)
}

// -------------------------------------------------------------------

// GetLastUnitHashRequest

// string public_key = 1;
inline void GetLastUnitHashRequest::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetLastUnitHashRequest::public_key() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetLastUnitHashRequest.public_key)
  return public_key_.GetNoArena();
}
inline void GetLastUnitHashRequest::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetLastUnitHashRequest.public_key)
}
#if LANG_CXX11
inline void GetLastUnitHashRequest::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetLastUnitHashRequest.public_key)
}
#endif
inline void GetLastUnitHashRequest::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetLastUnitHashRequest.public_key)
}
inline void GetLastUnitHashRequest::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetLastUnitHashRequest.public_key)
}
inline ::std::string* GetLastUnitHashRequest::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetLastUnitHashRequest.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLastUnitHashRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetLastUnitHashRequest.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLastUnitHashRequest::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetLastUnitHashRequest.public_key)
}

// -------------------------------------------------------------------

// GetLastUnitHashReplay

// bool result = 1;
inline void GetLastUnitHashReplay::clear_result() {
  result_ = false;
}
inline bool GetLastUnitHashReplay::result() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetLastUnitHashReplay.result)
  return result_;
}
inline void GetLastUnitHashReplay::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:ambr.rpc.GetLastUnitHashReplay.result)
}

// string hash = 2;
inline void GetLastUnitHashReplay::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetLastUnitHashReplay::hash() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetLastUnitHashReplay.hash)
  return hash_.GetNoArena();
}
inline void GetLastUnitHashReplay::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetLastUnitHashReplay.hash)
}
#if LANG_CXX11
inline void GetLastUnitHashReplay::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetLastUnitHashReplay.hash)
}
#endif
inline void GetLastUnitHashReplay::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetLastUnitHashReplay.hash)
}
inline void GetLastUnitHashReplay::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetLastUnitHashReplay.hash)
}
inline ::std::string* GetLastUnitHashReplay::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetLastUnitHashReplay.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLastUnitHashReplay::release_hash() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetLastUnitHashReplay.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLastUnitHashReplay::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetLastUnitHashReplay.hash)
}

// string error_message = 3;
inline void GetLastUnitHashReplay::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetLastUnitHashReplay::error_message() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.GetLastUnitHashReplay.error_message)
  return error_message_.GetNoArena();
}
inline void GetLastUnitHashReplay::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.GetLastUnitHashReplay.error_message)
}
#if LANG_CXX11
inline void GetLastUnitHashReplay::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.GetLastUnitHashReplay.error_message)
}
#endif
inline void GetLastUnitHashReplay::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.GetLastUnitHashReplay.error_message)
}
inline void GetLastUnitHashReplay::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.GetLastUnitHashReplay.error_message)
}
inline ::std::string* GetLastUnitHashReplay::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.GetLastUnitHashReplay.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLastUnitHashReplay::release_error_message() {
  // @@protoc_insertion_point(field_release:ambr.rpc.GetLastUnitHashReplay.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLastUnitHashReplay::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.GetLastUnitHashReplay.error_message)
}

// -------------------------------------------------------------------

// MessageStreamRequest

// -------------------------------------------------------------------

// MessageStreamReply

// string public_key = 1;
inline void MessageStreamReply::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageStreamReply::public_key() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.MessageStreamReply.public_key)
  return public_key_.GetNoArena();
}
inline void MessageStreamReply::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.MessageStreamReply.public_key)
}
#if LANG_CXX11
inline void MessageStreamReply::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.MessageStreamReply.public_key)
}
#endif
inline void MessageStreamReply::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.MessageStreamReply.public_key)
}
inline void MessageStreamReply::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.MessageStreamReply.public_key)
}
inline ::std::string* MessageStreamReply::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.MessageStreamReply.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageStreamReply::release_public_key() {
  // @@protoc_insertion_point(field_release:ambr.rpc.MessageStreamReply.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageStreamReply::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.MessageStreamReply.public_key)
}

// string message = 2;
inline void MessageStreamReply::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessageStreamReply::message() const {
  // @@protoc_insertion_point(field_get:ambr.rpc.MessageStreamReply.message)
  return message_.GetNoArena();
}
inline void MessageStreamReply::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ambr.rpc.MessageStreamReply.message)
}
#if LANG_CXX11
inline void MessageStreamReply::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ambr.rpc.MessageStreamReply.message)
}
#endif
inline void MessageStreamReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ambr.rpc.MessageStreamReply.message)
}
inline void MessageStreamReply::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ambr.rpc.MessageStreamReply.message)
}
inline ::std::string* MessageStreamReply::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:ambr.rpc.MessageStreamReply.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageStreamReply::release_message() {
  // @@protoc_insertion_point(field_release:ambr.rpc.MessageStreamReply.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageStreamReply::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ambr.rpc.MessageStreamReply.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace ambr

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_rpc_2eproto
