
/**********************************************************************
 * Copyright (c) 2018 Ambr project
 * Written by kan                             *
 * Distributed under the MIT software license, see the accompanying   *
 * file COPYING or http://www.opensource.org/licenses/mit-license.php.*
 **********************************************************************/

#include <stdint.h>
#include <string>
#include <iostream>
#include <cstddef>
#include <stddef.h>
#include <string>
#include <string.h>
#include <vector>
#include <assert.h>

#ifndef AMBR_CRYPTO_BASE58_H_
#define AMBR_CRYPTO_BASE58_H_

namespace ambr {
namespace crypto {

//the predefined table for encode/decode
static const char* kBase58Table = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

static const int8_t kASCIITable[256] = {
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1, 0, 1, 2, 3, 4, 5, 6,  7, 8,-1,-1,-1,-1,-1,-1,
  -1, 9,10,11,12,13,14,15, 16,-1,17,18,19,20,21,-1,
  22,23,24,25,26,27,28,29, 30,31,32,-1,-1,-1,-1,-1,
  -1,33,34,35,36,37,38,39, 40,41,42,43,-1,44,45,46,
  47,48,49,50,51,52,53,54, 55,56,57,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
};

bool base58_decode2(const char* psz, std::vector<unsigned char>& vch) {
  // Skip leading spaces.
  while (*psz && isspace(*psz))
    psz++;
  // Skip and count leading '1's.
  int zeroes = 0;
  int length = 0;
  while (*psz == '1') {
    zeroes++;
    psz++;
  }
  // Allocate enough space in big-endian base256 representation.
  int size = strlen(psz) * 733 /1000 + 1; // log(58) / log(256), rounded up.
  std::vector<unsigned char> b256(size);
  // Process the characters.
  // guarantee not out of range
  static_assert(sizeof(kASCIITable)/sizeof(kASCIITable[0]) == 256, "kASCIITable.size() should be 256"); 
  while (*psz && !isspace(*psz)) {
    // Decode base58 character
    int carry = kASCIITable[(uint8_t)*psz];
    if (carry == -1)  // Invalid b58 character
      return false;
    int i = 0;
    for (auto it = b256.rbegin(); (carry != 0 || i < length) && (it != b256.rend()); ++it, ++i) {
      carry += 58 * (*it);
      *it = carry % 256;
      carry /= 256;
    }
    assert(carry == 0);
    length = i;
    psz++;
  }
  // Skip trailing spaces.
  while (isspace(*psz))
      psz++;
  if (*psz != 0)
      return false;
  // Skip leading zeroes in b256.
  std::vector<unsigned char>::iterator it = b256.begin() + (size - length);
  while (it != b256.end() && *it == 0)
      it++;

  // Copy result into output vector.
  vch.reserve(zeroes + (b256.end() - it));
  vch.assign(zeroes, 0x00);
  while (it != b256.end())
      vch.push_back(*(it++));
  return true;
}

std::string base58_encode(const unsigned char* pbegin, const unsigned char* pend) {
  // Skip & count leading zeroes.
  int zeroes = 0;
  int length = 0;
  while (pbegin != pend && *pbegin == 0) {
    pbegin++;
    zeroes++;
  }
  // Allocate enough space in big-endian base58 representation.
  int size = (pend - pbegin) * 138 / 100 + 1; // log(256) / log(58), rounded up.
  std::vector<unsigned char> b58(size);
  // Process the bytes.
  while (pbegin != pend) {
    int carry = *pbegin;
    int i = 0;
    // Apply "b58 = b58 * 256 + ch".
    for (auto it = b58.rbegin(); (carry != 0 || i < length) && (it != b58.rend()); it++, i++) {
      carry += 256 * (*it);
      *it = carry % 58;
      carry /= 58;
    }

    assert(carry == 0);
    length = i;
    pbegin++;
  }
  // Skip leading zeroes in base58 result.
  std::vector<unsigned char>::iterator it = b58.begin() + (size - length);
  while (it != b58.end() && *it == 0)
    it++;
  // Translate the result into a string.
  std::string str;
  str.reserve(zeroes + (b58.end() - it));
  str.assign(zeroes, '1');
  while (it != b58.end())
    str += kBase58Table[*(it++)];
  return str;
}

std::string base58_encode(const std::vector<unsigned char>& vch) {
  return base58_encode(vch.data(), vch.data() + vch.size());
}

bool base58_decode(const std::string& str, std::vector<unsigned char>& vchRet) {
  return base58_decode2(str.c_str(), vchRet);
}

} //end crypto
} //end ambr

#endif